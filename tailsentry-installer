#!/bin/bash
# TailSentry Universal Installer/Manager
# Version: 1.0.0
# 
# This script handles:
# - Fresh installation
# - Updates
# - Uninstallation
# - Dependency management
# - Service management

set -e  # Exit on any error

# ============================================================================
# CONFIGURATION
# ============================================================================

SCRIPT_VERSION="1.0.0"
APP_NAME="TailSentry"
INSTALL_DIR="/opt/tailsentry"
SERVICE_NAME="tailsentry"
SERVICE_FILE="/etc/systemd/system/tailsentry.service"
REPO_URL="https://github.com/lolerskatez/TailSentry.git"
BACKUP_DIR="/opt/tailsentry-backups"
LOG_FILE="/tmp/tailsentry-installer.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

log() {
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

info() {
    log "${BLUE}[INFO]${NC} $1"
}

success() {
    log "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    log "${YELLOW}[WARNING]${NC} $1"
}

error() {
    log "${RED}[ERROR]${NC} $1"
}

fatal() {
    error "$1"
    exit 1
}

print_header() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════════════╗"
    echo "║                        $APP_NAME INSTALLER                           ║"
    echo "║                        Version: $SCRIPT_VERSION                              ║"
    echo "╚══════════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

print_separator() {
    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════${NC}"
}


check_root() {
    if [[ "$EUID" -ne 0 ]]; then
        fatal "This script must be run as root. Please use 'sudo $0'"
    fi
}

check_system() {
    info "Checking system requirements..."
    
    # Check OS
    if [[ ! -f /etc/os-release ]]; then
        fatal "Unsupported operating system"
    fi
    
    # Check for required commands
    local required_commands=("systemctl" "python3" "git" "curl")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            fatal "Required command '$cmd' not found"
        fi
    done
    
    # Check Python version
    local python_version
    python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    local min_version="3.9"
    
    if [[ "$(printf '%s\n' "$min_version" "$python_version" | sort -V | head -n1)" != "$min_version" ]]; then
        fatal "Python $min_version or higher is required. Found: $python_version"
    fi
    
    # Check for Tailscale
    if ! command -v tailscale &> /dev/null; then
        warning "Tailscale is not installed or not in PATH"
        if confirm "Do you want to continue anyway?"; then
            warning "You will need to install Tailscale manually later"
        else
            fatal "Installation cancelled"
        fi
    fi
    
    success "System requirements check passed"
}

install_dependencies() {
    info "Installing system dependencies..."
    
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        apt-get update
        apt-get install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v yum &> /dev/null; then
        yum update -y
        yum install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v dnf &> /dev/null; then
        dnf update -y
        dnf install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v pacman &> /dev/null; then
        pacman -Syu --noconfirm
        pacman -S --noconfirm python python-pip git curl logrotate
    else
        fatal "Unsupported package manager. Please install dependencies manually."
    fi
    
    success "System dependencies installed"
}

# ============================================================================
# BACKUP FUNCTIONS
# ============================================================================

create_backup() {
    if [[ ! -d "$INSTALL_DIR" ]]; then
        info "No existing installation to backup"
        return 0
    fi
    
    local backup_name="tailsentry-backup-$(date +%Y%m%d-%H%M%S)"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    info "Creating backup: $backup_path"
    mkdir -p "$BACKUP_DIR"
    
    # Stop service before backup
    if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
        systemctl stop "$SERVICE_NAME"
        info "Service stopped for backup"
    fi
    
    # Create backup
    cp -r "$INSTALL_DIR" "$backup_path"
    
    # Compress backup
    tar -czf "$backup_path.tar.gz" -C "$BACKUP_DIR" "$backup_name"
    rm -rf "$backup_path"
    
    success "Backup created: $backup_path.tar.gz"
    
    # Keep only last 5 backups
    local backup_count
    backup_count=$(find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" | wc -l)
    if [[ "$backup_count" -gt 5 ]]; then
        find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" -type f -printf '%T@ %p\n' | \
        sort -n | head -n $((backup_count - 5)) | cut -d' ' -f2- | xargs rm -f
        info "Old backups cleaned up"
    fi
}

list_backups() {
    print_separator
    echo -e "${WHITE}Available Backups:${NC}"
    
    if [[ ! -d "$BACKUP_DIR" ]] || [[ -z "$(ls -A "$BACKUP_DIR"/*.tar.gz 2>/dev/null)" ]]; then
        echo "No backups found"
        return 0
    fi
    
    local i=1
    for backup in "$BACKUP_DIR"/tailsentry-backup-*.tar.gz; do
        if [[ -f "$backup" ]]; then
            local size
            size=$(du -h "$backup" | cut -f1)
            local date
            date=$(stat -c %y "$backup" | cut -d' ' -f1,2)
            printf "%2d. %s (%s) - %s\n" "$i" "$(basename "$backup")" "$size" "$date"
            ((i++))
        fi
    done
}

restore_backup() {
    list_backups
    
    if [[ ! -d "$BACKUP_DIR" ]] || [[ -z "$(ls -A "$BACKUP_DIR"/*.tar.gz 2>/dev/null)" ]]; then
        error "No backups available to restore"
        return 1
    fi
    
    echo ""
    read -r -p "Enter backup number to restore (or 'q' to quit): " backup_choice
    
    if [[ "$backup_choice" == "q" ]]; then
        return 0
    fi
    
    local backup_files=("$BACKUP_DIR"/tailsentry-backup-*.tar.gz)
    local selected_backup="${backup_files[$((backup_choice - 1))]}"
    
    if [[ ! -f "$selected_backup" ]]; then
        error "Invalid backup selection"
        return 1
    fi
    
    if confirm "Are you sure you want to restore $(basename "$selected_backup")?"; then
        info "Restoring backup: $(basename "$selected_backup")"
        
        # Stop service
        systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        
        # Remove current installation
        if [[ -d "$INSTALL_DIR" ]]; then
            rm -rf "$INSTALL_DIR"
        fi
        
        # Extract backup
        tar -xzf "$selected_backup" -C "$(dirname "$INSTALL_DIR")"
        
        # Start service
        systemctl start "$SERVICE_NAME"
        
        success "Backup restored successfully"
    fi
}

# ============================================================================
# INSTALLATION FUNCTIONS
# ============================================================================

fresh_install() {
    info "Starting fresh installation..."
    
    # Check if installation already exists
    if [[ -d "$INSTALL_DIR" ]]; then
        error "$APP_NAME is already installed at $INSTALL_DIR"
        warning "Use 'Install & Override' if you want to reinstall, or 'Update Existing' to preserve data"
        return 1
    fi
    
    # Proceed with installation
    check_system
    install_dependencies
    download_application
    setup_python_environment
    configure_application
    install_service
    systemctl start "$SERVICE_NAME"
    success "$APP_NAME fresh installation completed!"
}

install_and_override() {
    warning "DANGEROUS OPERATION: This will delete all existing data!"
    echo -e "${RED}This will permanently delete:${NC}"
    echo "  - User accounts and passwords"
    echo "  - Configuration settings"
    echo "  - Application data"
    echo "  - Logs and backups"
    echo ""
    
    if [[ -d "$INSTALL_DIR" ]]; then
        echo -e "${YELLOW}Current installation found at: $INSTALL_DIR${NC}"
        
        if ! confirm "Are you ABSOLUTELY SURE you want to delete everything and reinstall?"; then
            info "Installation cancelled by user"
            return 0
        fi
        
        # Final confirmation
        echo ""
        warning "FINAL WARNING: This action cannot be undone!"
        if ! confirm "Type 'yes' to proceed with complete deletion and reinstall" "yes"; then
            info "Installation cancelled by user"
            return 0
        fi
        
        # Stop service if running
        if systemctl is-active --quiet "$SERVICE_NAME"; then
            systemctl stop "$SERVICE_NAME"
        fi
        
        # Remove service file
        if [[ -f "/etc/systemd/system/$SERVICE_NAME.service" ]]; then
            rm -f "/etc/systemd/system/$SERVICE_NAME.service"
            systemctl daemon-reload
        fi
        
        # Remove installation directory
        rm -rf "$INSTALL_DIR"
        success "Previous installation removed"
    fi
    
    # Proceed with fresh installation
    check_system
    install_dependencies
    download_application
    setup_python_environment
    configure_application
    install_service
    systemctl start "$SERVICE_NAME"
    success "$APP_NAME installation with override completed!"
}

# Enhanced confirm function that supports custom expected input
confirm() {
    local message="$1"
    local expected="${2:-y}"
    local prompt
    
    if [[ "$expected" == "yes" ]]; then
        prompt="yes/no"
    else
        prompt="y/n"
    fi
    
    while true; do
        read -r -p "$message [$prompt]: " response
        case "$response" in
            [Yy]|[Yy][Ee][Ss])
                [[ "$expected" == "yes" && "$response" =~ ^[Yy][Ee][Ss]$ ]] && return 0
                [[ "$expected" != "yes" ]] && return 0
                ;;
            [Nn]|[Nn][Oo])
                return 1
                ;;
            *)
                if [[ "$expected" == "yes" ]]; then
                    echo "Please type 'yes' or 'no'"
                else
                    echo "Please answer y or n"
                fi
                ;;
        esac
    done
}

download_application() {
    info "Downloading $APP_NAME..."
    
    if [[ -d "$INSTALL_DIR" ]]; then
        rm -rf "$INSTALL_DIR"
    fi
    
    mkdir -p "$INSTALL_DIR"
    
    if ! git clone "$REPO_URL" "$INSTALL_DIR"; then
        fatal "Failed to download $APP_NAME from repository"
    fi
    
    success "$APP_NAME downloaded successfully"
}

setup_python_environment() {
    info "Setting up Python virtual environment..."
    
    cd "$INSTALL_DIR"
    
    # Create virtual environment
    python3 -m venv venv
    
    # Activate virtual environment
    source venv/bin/activate
    
    # Upgrade pip
    pip install --upgrade pip
    
    # Install requirements
    if [[ -f "requirements.txt" ]]; then
        pip install -r requirements.txt
    else
        fatal "requirements.txt not found"
    fi
    
    success "Python environment set up successfully"
}

configure_application() {
    info "Configuring $APP_NAME..."
    
    cd "$INSTALL_DIR"
    
    # Create necessary directories
    mkdir -p config data logs
    
    # Set up configuration files
    if [[ ! -f "config/tailsentry_config.json" ]]; then
        cat > "config/tailsentry_config.json" << 'EOF'
{
    "host": "0.0.0.0",
    "port": 8080,
    "debug": false,
    "secret_key": "",
    "database_path": "data/users.db",
    "log_level": "INFO",
    "max_login_attempts": 5,
    "lockout_duration": 300,
    "session_timeout": 3600,
    "enable_notifications": true,
    "backup_retention_days": 30
}
EOF
    fi
    
    # Generate secret key if not present
    if ! grep -q '"secret_key": "[^"]\+"' config/tailsentry_config.json; then
        local secret_key
        secret_key=$(python3 -c "import secrets; print(secrets.token_hex(32))")
        sed -i "s/\"secret_key\": \"\"/\"secret_key\": \"$secret_key\"/" config/tailsentry_config.json
    fi
    
    # Set up Tailscale configuration
    if [[ ! -f "config/tailscale_settings.json" ]]; then
        cat > "config/tailscale_settings.json" << 'EOF'
{
    "auth_key": "",
    "api_key": "",
    "tailnet": "",
    "auto_approve": false,
    "ephemeral": false
}
EOF
        
        # Prompt for Tailscale settings
        echo ""
        echo -e "${WHITE}Tailscale Configuration:${NC}"
        echo "You can configure these settings later through the web interface"
        echo "or by editing config/tailscale_settings.json"
    fi
    
    # Create .env file with secure session secret
    if [[ ! -f ".env" ]] || [[ ! -s ".env" ]]; then
        info "Generating secure session secret..."
        local session_secret
        session_secret=$(python3 -c "import secrets; print(secrets.token_urlsafe(32))")
        
        # Optional Tailscale PAT configuration
        echo ""
        echo -e "${WHITE}Tailscale Personal Access Token Configuration:${NC}"
        echo "To use real Tailscale data instead of demo data, you need a Personal Access Token."
        echo "You can:"
        echo "  1. Enter your token now (recommended)"
        echo "  2. Configure it later through the TailSentry web interface"
        echo "  3. Skip for now and use demo data"
        echo ""
        echo "To get a token, visit: https://login.tailscale.com/admin/settings/keys"
        echo ""
        
        local tailscale_pat=""
        read -r -p "Enter your Tailscale Personal Access Token (or press Enter to skip): " tailscale_pat
        
        # Create .env file
        cat > ".env" << EOF
# TailSentry Environment Configuration
# Generated on $(date)

# Security Settings
SESSION_SECRET='$session_secret'
SESSION_TIMEOUT_MINUTES='30'
DEVELOPMENT='true'

# Tailscale Integration
EOF

        if [[ -n "$tailscale_pat" ]]; then
            echo "TAILSCALE_PAT='$tailscale_pat'" >> ".env"
            echo "# Tailscale PAT configured during installation" >> ".env"
        else
            echo "# TAILSCALE_PAT='your_tailscale_personal_access_token_here'" >> ".env"
            echo "# Configure your Tailscale PAT through the web interface: Settings > Tailscale" >> ".env"
        fi
        
        cat >> ".env" << EOF
TAILSCALE_TAILNET='-'
TAILSCALE_API_TIMEOUT='10'
TAILSENTRY_FORCE_LIVE_DATA='true'
TAILSENTRY_DATA_DIR='/opt/tailsentry/data'

# Application Settings  
LOG_LEVEL='INFO'
LOG_FORMAT='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
HEALTH_CHECK_ENABLED='true'
HEALTH_CHECK_INTERVAL='300'
BACKUP_ENABLED='true'
BACKUP_RETENTION_DAYS='30'
ALLOWED_ORIGIN='*'
EOF
        chmod 600 ".env"
        success "Environment configuration created with secure session secret"
    else
        info "Environment file already exists, skipping creation"
    fi

    # Set proper permissions
    chmod 600 config/*.json
    chown -R root:root "$INSTALL_DIR"
    
    success "$APP_NAME configured successfully"
}

install_service() {
    info "Installing systemd service..."
    
    # Create service file
    cat > "$SERVICE_FILE" << EOF
[Unit]
Description=$APP_NAME Dashboard
After=network.target tailscaled.service
Requires=network.target
Wants=tailscaled.service

[Service]
Type=simple
User=root
Group=root
WorkingDirectory=$INSTALL_DIR
ExecStart=$INSTALL_DIR/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8080
Restart=always
RestartSec=5
Environment=PATH=$INSTALL_DIR/venv/bin:/usr/local/bin:/usr/bin:/bin
Environment=PYTHONPATH=$INSTALL_DIR
StandardOutput=journal
StandardError=journal
SyslogIdentifier=tailsentry

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=$INSTALL_DIR

[Install]
WantedBy=multi-user.target
EOF
    
    # Set up logrotate
    cat > "/etc/logrotate.d/tailsentry" << EOF
$INSTALL_DIR/logs/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    copytruncate
}
EOF
    
    # Reload systemd and enable service
    systemctl daemon-reload
    systemctl enable "$SERVICE_NAME"
    
    success "Service installed and enabled"
}

# ============================================================================
# UPDATE FUNCTIONS
# ============================================================================

update_application() {
    info "Updating $APP_NAME..."
    
    # Create backup before update
    create_backup
    
    # Stop service
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        systemctl stop "$SERVICE_NAME"
        info "Service stopped for update"
    fi
    
    cd "$INSTALL_DIR"
    
    # Backup user configuration files
    local temp_backup="/tmp/tailsentry-config-backup-$(date +%s)"
    mkdir -p "$temp_backup"
    
    [[ -f ".env" ]] && cp ".env" "$temp_backup/"
    [[ -f "config/tailsentry_config.json" ]] && cp "config/tailsentry_config.json" "$temp_backup/"
    [[ -f "config/tailscale_settings.json" ]] && cp "config/tailscale_settings.json" "$temp_backup/"
    [[ -d "data" ]] && cp -r "data" "$temp_backup/"
    
    info "Configuration backed up to $temp_backup"
    
    # Stash any local changes
    git stash push -m "Auto-stash before update $(date)"
    
    # Update from repository
    git fetch origin
    git reset --hard origin/main
    
    # Restore user configuration files
    [[ -f "$temp_backup/.env" ]] && cp "$temp_backup/.env" ".env"
    [[ -f "$temp_backup/tailsentry_config.json" ]] && cp "$temp_backup/tailsentry_config.json" "config/"
    [[ -f "$temp_backup/tailscale_settings.json" ]] && cp "$temp_backup/tailscale_settings.json" "config/"
    [[ -d "$temp_backup/data" ]] && cp -r "$temp_backup/data"/* "data/" 2>/dev/null
    
    # Clean up temporary backup
    rm -rf "$temp_backup"
    info "Configuration restored"
    
    # Update Python dependencies
    source venv/bin/activate
    pip install --upgrade pip
    pip install -r requirements.txt --upgrade
    
    # Start service
    systemctl start "$SERVICE_NAME"
    
    success "$APP_NAME updated successfully"
}

update_dependencies() {
    info "Updating Python dependencies..."
    
    cd "$INSTALL_DIR"
    source venv/bin/activate
    
    # Update pip first
    pip install --upgrade pip
    
    # Update all packages
    pip install -r requirements.txt --upgrade
    
    # Restart service to apply changes
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        systemctl restart "$SERVICE_NAME"
        info "Service restarted"
    fi
    
    success "Dependencies updated successfully"
}

# ============================================================================
# UNINSTALLATION FUNCTIONS
# ============================================================================

uninstall_application() {
    print_separator
    echo -e "${RED}WARNING: This will completely remove $APP_NAME from your system.${NC}"
    echo "The following will be removed:"
    echo "  - Application files ($INSTALL_DIR)"
    echo "  - Systemd service ($SERVICE_FILE)"
    echo "  - Log rotation configuration"
    echo ""
    echo "The following will be preserved:"
    echo "  - Backups ($BACKUP_DIR)"
    echo "  - System packages installed as dependencies"
    echo ""
    
    if ! confirm "Are you sure you want to proceed?"; then
        info "Uninstallation cancelled"
        return 0
    fi
    
    info "Uninstalling $APP_NAME..."
    
    # Stop and disable service
    if systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
        systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        info "Service stopped and disabled"
    fi
    
    # Remove service file
    if [[ -f "$SERVICE_FILE" ]]; then
        rm -f "$SERVICE_FILE"
        systemctl daemon-reload
        info "Service file removed"
    fi
    
    # Remove logrotate configuration
    if [[ -f "/etc/logrotate.d/tailsentry" ]]; then
        rm -f "/etc/logrotate.d/tailsentry"
        info "Logrotate configuration removed"
    fi
    
    # Kill any running processes
    pkill -f "uvicorn.*main:app" 2>/dev/null || true
    pkill -f "python.*main.py" 2>/dev/null || true
    
    # Remove application directory
    if [[ -d "$INSTALL_DIR" ]]; then
        rm -rf "$INSTALL_DIR"
        info "Application files removed"
    fi
    
    success "$APP_NAME uninstalled successfully"
    
    if [[ -d "$BACKUP_DIR" ]]; then
        echo ""
        if confirm "Do you want to remove backups as well?"; then
            rm -rf "$BACKUP_DIR"
            success "Backups removed"
        else
            info "Backups preserved in $BACKUP_DIR"
        fi
    fi
}

# ============================================================================
# STATUS AND MANAGEMENT FUNCTIONS
# ============================================================================

show_status() {
    print_separator
    echo -e "${WHITE}$APP_NAME Status:${NC}"
    
    # Check if installed
    if [[ ! -d "$INSTALL_DIR" ]]; then
        echo -e "Installation: ${RED}Not installed${NC}"
        return 1
    fi
    
    echo -e "Installation: ${GREEN}Installed${NC} ($INSTALL_DIR)"
    
    # Check version
    if [[ -f "$INSTALL_DIR/version.py" ]]; then
        local version
        version=$(cd "$INSTALL_DIR" && python3 -c "from version import VERSION; print(VERSION)" 2>/dev/null || echo "Unknown")
        echo -e "Version: ${CYAN}$version${NC}"
    fi
    
    # Check service status
    if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
        echo -e "Service: ${GREEN}Running${NC}"
        local port
        port=$(netstat -tlnp 2>/dev/null | grep ":8080" | wc -l)
        if [[ "$port" -gt 0 ]]; then
            echo -e "Web Interface: ${GREEN}Available${NC} (http://localhost:8080)"
        fi
    elif systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
        echo -e "Service: ${YELLOW}Stopped${NC} (but enabled)"
    else
        echo -e "Service: ${RED}Not configured${NC}"
    fi
    
    # Check last backup
    if [[ -d "$BACKUP_DIR" ]]; then
        local latest_backup
        latest_backup=$(find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
        if [[ -n "$latest_backup" ]]; then
            local backup_date
            backup_date=$(stat -c %y "$latest_backup" | cut -d' ' -f1)
            echo -e "Last Backup: ${CYAN}$backup_date${NC}"
        fi
    fi
    
    # Check disk usage
    if [[ -d "$INSTALL_DIR" ]]; then
        local disk_usage
        disk_usage=$(du -sh "$INSTALL_DIR" 2>/dev/null | cut -f1)
        echo -e "Disk Usage: ${CYAN}$disk_usage${NC}"
    fi
}

manage_service() {
    local action="$1"
    
    case "$action" in
        "start")
            systemctl start "$SERVICE_NAME"
            success "Service started"
            ;;
        "stop")
            systemctl stop "$SERVICE_NAME"
            success "Service stopped"
            ;;
        "restart")
            systemctl restart "$SERVICE_NAME"
            success "Service restarted"
            ;;
        "enable")
            systemctl enable "$SERVICE_NAME"
            success "Service enabled"
            ;;
        "disable")
            systemctl disable "$SERVICE_NAME"
            success "Service disabled"
            ;;
        "logs")
            journalctl -u "$SERVICE_NAME" -f
            ;;
        *)
            error "Unknown service action: $action"
            return 1
            ;;
    esac
}

# ============================================================================
# SECURITY FUNCTIONS
# ============================================================================

regenerate_session_secret() {
    info "Regenerating session secret..."
    
    if [[ ! -f "$INSTALL_DIR/.env" ]]; then
        error ".env file not found. Please run 'install' first."
        return 1
    fi
    
    # Generate new session secret
    local new_secret
    new_secret=$(python3 -c "import secrets; print(secrets.token_urlsafe(32))")
    
    # Backup current .env
    cp "$INSTALL_DIR/.env" "$INSTALL_DIR/.env.backup.$(date +%s)"
    
    # Update the session secret
    sed -i "s/^SESSION_SECRET=.*/SESSION_SECRET=$new_secret/" "$INSTALL_DIR/.env"
    
    success "Session secret regenerated"
    
    # Restart service if running
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        warning "Restarting service to apply new session secret..."
        systemctl restart "$SERVICE_NAME"
        success "Service restarted"
    else
        warning "Service is not running. Start it to apply the new session secret."
    fi
    
    info "Note: All users will need to log in again due to the new session secret."
}

# ============================================================================
# MENU FUNCTIONS
# ============================================================================

show_help() {
    cat << EOF
$APP_NAME Installer/Manager v$SCRIPT_VERSION

USAGE:
    $0 [COMMAND] [OPTIONS]

INSTALLATION COMMANDS:
    install         Fresh installation (fails if already exists)
    install-override DANGEROUS: Wipe existing data and reinstall
    update          Update existing installation (preserves data)
    uninstall       Remove $APP_NAME completely

MAINTENANCE COMMANDS:
    status          Show current status
    backup          Create manual backup
    restore         Restore from backup
    list-backups    List available backups
    update-deps     Update Python dependencies only
    
SECURITY COMMANDS:
    regen-secret    Regenerate session secret (requires restart)
    
SERVICE MANAGEMENT:
    start           Start the service
    stop            Stop the service
    restart         Restart the service
    enable          Enable service auto-start
    disable         Disable service auto-start
    logs            Show service logs (live)
    
OTHER:
    help            Show this help message

EXAMPLES:
    $0                      # Interactive menu (recommended)
    $0 install              # Fresh installation
    $0 install-override     # DANGEROUS: Reinstall and wipe data
    $0 update               # Update preserving data
    $0 status               # Check status
    $0 restart              # Restart service
    $0 regen-secret         # Generate new session secret
    $0 logs                 # Show live logs

INTERACTIVE MODE:
    Run without arguments to use the interactive menu with detailed
    descriptions and safety warnings for each operation.

For more information, visit: https://github.com/lolerskatez/TailSentry
EOF
}

interactive_menu() {
    while true; do
        print_header
        show_status 2>/dev/null || true
        print_separator
        
        echo -e "${WHITE}Installation Options:${NC}"
        echo "1. Fresh Install (New installation only - fails if already exists)"
        echo "2. Install & Override (DANGEROUS - Wipes existing data and reinstalls)"
        echo "3. Update Existing (Preserves data, applies fixes and updates)"
        echo "4. Remove Installation (Complete uninstall)"
        echo ""
        echo -e "${WHITE}Maintenance Options:${NC}"
        echo "5. Create Backup"
        echo "6. Restore from Backup"
        echo "7. List Backups"
        echo "8. Update Dependencies Only"
        echo ""
        echo -e "${WHITE}Security Options:${NC}"
        echo "9. Regenerate Session Secret"
        echo ""
        echo -e "${WHITE}Service Management:${NC}"
        echo "10. Service Control Menu"
        echo "11. View Live Logs"
        echo ""
        echo -e "${WHITE}Other:${NC}"
        echo "12. Show Installation Status"
        echo "0. Exit"
        echo ""
        
        read -r -p "Choose an option [0-12]: " choice
        
        case "$choice" in
            1)
                check_root
                fresh_install
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            2)
                check_root
                install_and_override
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            3)
                check_root
                update_application
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            4)
                check_root
                uninstall_application
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            5)
                check_root
                create_backup
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            6)
                check_root
                restore_backup
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            7)
                list_backups
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            8)
                check_root
                update_dependencies
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            9)
                check_root
                regenerate_session_secret
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            10)
                service_menu
                ;;
            11)
                manage_service "logs"
                ;;
            12)
                show_status
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            0)
                echo "Goodbye!"
                exit 0
                ;;
            *)
                error "Invalid option"
                sleep 1
                ;;
        esac
    done
}

service_menu() {
    while true; do
        print_separator
        echo -e "${WHITE}Service Management:${NC}"
        echo "1. Start Service"
        echo "2. Stop Service"
        echo "3. Restart Service"
        echo "4. Enable Auto-start"
        echo "5. Disable Auto-start"
        echo "6. View Logs"
        echo "0. Back to Main Menu"
        echo ""
        
        read -r -p "Choose an option [0-6]: " choice
        
        case "$choice" in
            1) manage_service "start"; read -r -p "Press Enter to continue..." ;;
            2) manage_service "stop"; read -r -p "Press Enter to continue..." ;;
            3) manage_service "restart"; read -r -p "Press Enter to continue..." ;;
            4) manage_service "enable"; read -r -p "Press Enter to continue..." ;;
            5) manage_service "disable"; read -r -p "Press Enter to continue..." ;;
            6) manage_service "logs" ;;
            0) break ;;
            *) error "Invalid option"; sleep 1 ;;
        esac
    done
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    # Create log file
    touch "$LOG_FILE"
    
    # Handle command line arguments
    case "${1:-}" in
        "install")
            print_header
            check_root
            fresh_install
            ;;
        "install-override")
            print_header
            check_root
            install_and_override
            ;;
        "update")
            check_root
            update_application
            ;;
        "update-deps")
            check_root
            update_dependencies
            ;;
        "uninstall")
            check_root
            uninstall_application
            ;;
        "status")
            show_status
            ;;
        "backup")
            check_root
            create_backup
            ;;
        "restore")
            check_root
            restore_backup
            ;;
        "list-backups")
            list_backups
            ;;
        "regen-secret")
            check_root
            regenerate_session_secret
            ;;
        "start"|"stop"|"restart"|"enable"|"disable"|"logs")
            check_root
            manage_service "$1"
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        "")
            # No arguments - run interactive menu
            interactive_menu
            ;;
        *)
            error "Unknown command: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
