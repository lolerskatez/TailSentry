#!/bin/bash
# TailSentry Universal Installer/Manager
# Version: 1.0.0
# 
# This script handles:
# - Fresh installation
# - Updates
# - Uninstallation
# - Dependency management
# - Service management

set -e  # Exit on any error

# ============================================================================
# CONFIGURATION
# ============================================================================

SCRIPT_VERSION="1.0.0"
APP_NAME="TailSentry"
INSTALL_DIR="/opt/tailsentry"
SERVICE_NAME="tailsentry"
SERVICE_FILE="/etc/systemd/system/tailsentry.service"
REPO_URL="https://github.com/lolerskatez/TailSentry.git"
BACKUP_DIR="/opt/tailsentry-backups"
LOG_FILE="/tmp/tailsentry-installer.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# ============================================================================
# UTILITY FUNCTIONS
# ============================================================================

log() {
    echo -e "$(date '+%Y-%m-%d %H:%M:%S') - $1" | tee -a "$LOG_FILE"
}

info() {
    log "${BLUE}[INFO]${NC} $1"
}

success() {
    log "${GREEN}[SUCCESS]${NC} $1"
}

warning() {
    log "${YELLOW}[WARNING]${NC} $1"
}

error() {
    log "${RED}[ERROR]${NC} $1"
}

fatal() {
    error "$1"
    exit 1
}

print_header() {
    echo -e "${CYAN}"
    echo "╔══════════════════════════════════════════════════════════════════════╗"
    echo "║                        $APP_NAME INSTALLER                           ║"
    echo "║                        Version: $SCRIPT_VERSION                              ║"
    echo "╚══════════════════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
}

print_separator() {
    echo -e "${CYAN}════════════════════════════════════════════════════════════════════════${NC}"
}

confirm() {
    local prompt="$1"
    local default="${2:-n}"
    local response
    
    if [[ "$default" == "y" ]]; then
        prompt="$prompt [Y/n]: "
    else
        prompt="$prompt [y/N]: "
    fi
    
    read -r -p "$prompt" response
    response=${response:-$default}
    
    [[ "$response" =~ ^[Yy]$ ]]
}

check_root() {
    if [[ "$EUID" -ne 0 ]]; then
        fatal "This script must be run as root. Please use 'sudo $0'"
    fi
}

check_system() {
    info "Checking system requirements..."
    
    # Check OS
    if [[ ! -f /etc/os-release ]]; then
        fatal "Unsupported operating system"
    fi
    
    # Check for required commands
    local required_commands=("systemctl" "python3" "git" "curl")
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            fatal "Required command '$cmd' not found"
        fi
    done
    
    # Check Python version
    local python_version
    python_version=$(python3 -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')")
    local min_version="3.9"
    
    if [[ "$(printf '%s\n' "$min_version" "$python_version" | sort -V | head -n1)" != "$min_version" ]]; then
        fatal "Python $min_version or higher is required. Found: $python_version"
    fi
    
    # Check for Tailscale
    if ! command -v tailscale &> /dev/null; then
        warning "Tailscale is not installed or not in PATH"
        if confirm "Do you want to continue anyway?"; then
            warning "You will need to install Tailscale manually later"
        else
            fatal "Installation cancelled"
        fi
    fi
    
    success "System requirements check passed"
}

install_dependencies() {
    info "Installing system dependencies..."
    
    # Detect package manager
    if command -v apt-get &> /dev/null; then
        apt-get update
        apt-get install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v yum &> /dev/null; then
        yum update -y
        yum install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v dnf &> /dev/null; then
        dnf update -y
        dnf install -y python3 python3-venv python3-pip git curl logrotate
    elif command -v pacman &> /dev/null; then
        pacman -Syu --noconfirm
        pacman -S --noconfirm python python-pip git curl logrotate
    else
        fatal "Unsupported package manager. Please install dependencies manually."
    fi
    
    success "System dependencies installed"
}

# ============================================================================
# BACKUP FUNCTIONS
# ============================================================================

create_backup() {
    if [[ ! -d "$INSTALL_DIR" ]]; then
        info "No existing installation to backup"
        return 0
    fi
    
    local backup_name="tailsentry-backup-$(date +%Y%m%d-%H%M%S)"
    local backup_path="$BACKUP_DIR/$backup_name"
    
    info "Creating backup: $backup_path"
    mkdir -p "$BACKUP_DIR"
    
    # Stop service before backup
    if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
        systemctl stop "$SERVICE_NAME"
        info "Service stopped for backup"
    fi
    
    # Create backup
    cp -r "$INSTALL_DIR" "$backup_path"
    
    # Compress backup
    tar -czf "$backup_path.tar.gz" -C "$BACKUP_DIR" "$backup_name"
    rm -rf "$backup_path"
    
    success "Backup created: $backup_path.tar.gz"
    
    # Keep only last 5 backups
    local backup_count
    backup_count=$(find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" | wc -l)
    if [[ "$backup_count" -gt 5 ]]; then
        find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" -type f -printf '%T@ %p\n' | \
        sort -n | head -n $((backup_count - 5)) | cut -d' ' -f2- | xargs rm -f
        info "Old backups cleaned up"
    fi
}

list_backups() {
    print_separator
    echo -e "${WHITE}Available Backups:${NC}"
    
    if [[ ! -d "$BACKUP_DIR" ]] || [[ -z "$(ls -A "$BACKUP_DIR"/*.tar.gz 2>/dev/null)" ]]; then
        echo "No backups found"
        return 0
    fi
    
    local i=1
    for backup in "$BACKUP_DIR"/tailsentry-backup-*.tar.gz; do
        if [[ -f "$backup" ]]; then
            local size
            size=$(du -h "$backup" | cut -f1)
            local date
            date=$(stat -c %y "$backup" | cut -d' ' -f1,2)
            printf "%2d. %s (%s) - %s\n" "$i" "$(basename "$backup")" "$size" "$date"
            ((i++))
        fi
    done
}

restore_backup() {
    list_backups
    
    if [[ ! -d "$BACKUP_DIR" ]] || [[ -z "$(ls -A "$BACKUP_DIR"/*.tar.gz 2>/dev/null)" ]]; then
        error "No backups available to restore"
        return 1
    fi
    
    echo ""
    read -r -p "Enter backup number to restore (or 'q' to quit): " backup_choice
    
    if [[ "$backup_choice" == "q" ]]; then
        return 0
    fi
    
    local backup_files=("$BACKUP_DIR"/tailsentry-backup-*.tar.gz)
    local selected_backup="${backup_files[$((backup_choice - 1))]}"
    
    if [[ ! -f "$selected_backup" ]]; then
        error "Invalid backup selection"
        return 1
    fi
    
    if confirm "Are you sure you want to restore $(basename "$selected_backup")?"; then
        info "Restoring backup: $(basename "$selected_backup")"
        
        # Stop service
        systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        
        # Remove current installation
        if [[ -d "$INSTALL_DIR" ]]; then
            rm -rf "$INSTALL_DIR"
        fi
        
        # Extract backup
        tar -xzf "$selected_backup" -C "$(dirname "$INSTALL_DIR")"
        
        # Start service
        systemctl start "$SERVICE_NAME"
        
        success "Backup restored successfully"
    fi
}

# ============================================================================
# INSTALLATION FUNCTIONS
# ============================================================================

download_application() {
    info "Downloading $APP_NAME..."
    
    if [[ -d "$INSTALL_DIR" ]]; then
        rm -rf "$INSTALL_DIR"
    fi
    
    mkdir -p "$INSTALL_DIR"
    
    if ! git clone "$REPO_URL" "$INSTALL_DIR"; then
        fatal "Failed to download $APP_NAME from repository"
    fi
    
    success "$APP_NAME downloaded successfully"
}

setup_python_environment() {
    info "Setting up Python virtual environment..."
    
    cd "$INSTALL_DIR"
    
    # Create virtual environment
    python3 -m venv venv
    
    # Activate virtual environment
    source venv/bin/activate
    
    # Upgrade pip
    pip install --upgrade pip
    
    # Install requirements
    if [[ -f "requirements.txt" ]]; then
        pip install -r requirements.txt
    else
        fatal "requirements.txt not found"
    fi
    
    success "Python environment set up successfully"
}

configure_application() {
    info "Configuring $APP_NAME..."
    
    cd "$INSTALL_DIR"
    
    # Create necessary directories
    mkdir -p config data logs
    
    # Set up configuration files
    if [[ ! -f "config/tailsentry_config.json" ]]; then
        cat > "config/tailsentry_config.json" << 'EOF'
{
    "host": "0.0.0.0",
    "port": 8080,
    "debug": false,
    "secret_key": "",
    "database_path": "data/users.db",
    "log_level": "INFO",
    "max_login_attempts": 5,
    "lockout_duration": 300,
    "session_timeout": 3600,
    "enable_notifications": true,
    "backup_retention_days": 30
}
EOF
    fi
    
    # Generate secret key if not present
    if ! grep -q '"secret_key": "[^"]\+"' config/tailsentry_config.json; then
        local secret_key
        secret_key=$(python3 -c "import secrets; print(secrets.token_hex(32))")
        sed -i "s/\"secret_key\": \"\"/\"secret_key\": \"$secret_key\"/" config/tailsentry_config.json
    fi
    
    # Set up Tailscale configuration
    if [[ ! -f "config/tailscale_settings.json" ]]; then
        cat > "config/tailscale_settings.json" << 'EOF'
{
    "auth_key": "",
    "api_key": "",
    "tailnet": "",
    "auto_approve": false,
    "ephemeral": false
}
EOF
        
        # Prompt for Tailscale settings
        echo ""
        echo -e "${WHITE}Tailscale Configuration:${NC}"
        echo "You can configure these settings later through the web interface"
        echo "or by editing config/tailscale_settings.json"
    fi
    
    # Set proper permissions
    chmod 600 config/*.json
    chown -R root:root "$INSTALL_DIR"
    
    success "$APP_NAME configured successfully"
}

install_service() {
    info "Installing systemd service..."
    
    # Create service file
    cat > "$SERVICE_FILE" << EOF
[Unit]
Description=$APP_NAME Dashboard
After=network.target tailscaled.service
Requires=network.target
Wants=tailscaled.service

[Service]
Type=simple
User=root
Group=root
WorkingDirectory=$INSTALL_DIR
ExecStart=$INSTALL_DIR/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8080
Restart=always
RestartSec=5
Environment=PATH=$INSTALL_DIR/venv/bin:/usr/local/bin:/usr/bin:/bin
Environment=PYTHONPATH=$INSTALL_DIR
StandardOutput=journal
StandardError=journal
SyslogIdentifier=tailsentry

# Security settings
NoNewPrivileges=true
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=$INSTALL_DIR

[Install]
WantedBy=multi-user.target
EOF
    
    # Set up logrotate
    cat > "/etc/logrotate.d/tailsentry" << EOF
$INSTALL_DIR/logs/*.log {
    daily
    missingok
    rotate 7
    compress
    delaycompress
    notifempty
    copytruncate
}
EOF
    
    # Reload systemd and enable service
    systemctl daemon-reload
    systemctl enable "$SERVICE_NAME"
    
    success "Service installed and enabled"
}

# ============================================================================
# UPDATE FUNCTIONS
# ============================================================================

update_application() {
    info "Updating $APP_NAME..."
    
    # Create backup before update
    create_backup
    
    # Stop service
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        systemctl stop "$SERVICE_NAME"
        info "Service stopped for update"
    fi
    
    cd "$INSTALL_DIR"
    
    # Stash any local changes
    git stash push -m "Auto-stash before update $(date)"
    
    # Update from repository
    git fetch origin
    git reset --hard origin/main
    
    # Update Python dependencies
    source venv/bin/activate
    pip install --upgrade pip
    pip install -r requirements.txt --upgrade
    
    # Start service
    systemctl start "$SERVICE_NAME"
    
    success "$APP_NAME updated successfully"
}

update_dependencies() {
    info "Updating Python dependencies..."
    
    cd "$INSTALL_DIR"
    source venv/bin/activate
    
    # Update pip first
    pip install --upgrade pip
    
    # Update all packages
    pip install -r requirements.txt --upgrade
    
    # Restart service to apply changes
    if systemctl is-active --quiet "$SERVICE_NAME"; then
        systemctl restart "$SERVICE_NAME"
        info "Service restarted"
    fi
    
    success "Dependencies updated successfully"
}

# ============================================================================
# UNINSTALLATION FUNCTIONS
# ============================================================================

uninstall_application() {
    print_separator
    echo -e "${RED}WARNING: This will completely remove $APP_NAME from your system.${NC}"
    echo "The following will be removed:"
    echo "  - Application files ($INSTALL_DIR)"
    echo "  - Systemd service ($SERVICE_FILE)"
    echo "  - Log rotation configuration"
    echo ""
    echo "The following will be preserved:"
    echo "  - Backups ($BACKUP_DIR)"
    echo "  - System packages installed as dependencies"
    echo ""
    
    if ! confirm "Are you sure you want to proceed?"; then
        info "Uninstallation cancelled"
        return 0
    fi
    
    info "Uninstalling $APP_NAME..."
    
    # Stop and disable service
    if systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
        systemctl stop "$SERVICE_NAME" 2>/dev/null || true
        systemctl disable "$SERVICE_NAME" 2>/dev/null || true
        info "Service stopped and disabled"
    fi
    
    # Remove service file
    if [[ -f "$SERVICE_FILE" ]]; then
        rm -f "$SERVICE_FILE"
        systemctl daemon-reload
        info "Service file removed"
    fi
    
    # Remove logrotate configuration
    if [[ -f "/etc/logrotate.d/tailsentry" ]]; then
        rm -f "/etc/logrotate.d/tailsentry"
        info "Logrotate configuration removed"
    fi
    
    # Kill any running processes
    pkill -f "uvicorn.*main:app" 2>/dev/null || true
    pkill -f "python.*main.py" 2>/dev/null || true
    
    # Remove application directory
    if [[ -d "$INSTALL_DIR" ]]; then
        rm -rf "$INSTALL_DIR"
        info "Application files removed"
    fi
    
    success "$APP_NAME uninstalled successfully"
    
    if [[ -d "$BACKUP_DIR" ]]; then
        echo ""
        if confirm "Do you want to remove backups as well?"; then
            rm -rf "$BACKUP_DIR"
            success "Backups removed"
        else
            info "Backups preserved in $BACKUP_DIR"
        fi
    fi
}

# ============================================================================
# STATUS AND MANAGEMENT FUNCTIONS
# ============================================================================

show_status() {
    print_separator
    echo -e "${WHITE}$APP_NAME Status:${NC}"
    
    # Check if installed
    if [[ ! -d "$INSTALL_DIR" ]]; then
        echo -e "Installation: ${RED}Not installed${NC}"
        return 1
    fi
    
    echo -e "Installation: ${GREEN}Installed${NC} ($INSTALL_DIR)"
    
    # Check version
    if [[ -f "$INSTALL_DIR/version.py" ]]; then
        local version
        version=$(cd "$INSTALL_DIR" && python3 -c "from version import VERSION; print(VERSION)" 2>/dev/null || echo "Unknown")
        echo -e "Version: ${CYAN}$version${NC}"
    fi
    
    # Check service status
    if systemctl is-active --quiet "$SERVICE_NAME" 2>/dev/null; then
        echo -e "Service: ${GREEN}Running${NC}"
        local port
        port=$(netstat -tlnp 2>/dev/null | grep ":8080" | wc -l)
        if [[ "$port" -gt 0 ]]; then
            echo -e "Web Interface: ${GREEN}Available${NC} (http://localhost:8080)"
        fi
    elif systemctl is-enabled --quiet "$SERVICE_NAME" 2>/dev/null; then
        echo -e "Service: ${YELLOW}Stopped${NC} (but enabled)"
    else
        echo -e "Service: ${RED}Not configured${NC}"
    fi
    
    # Check last backup
    if [[ -d "$BACKUP_DIR" ]]; then
        local latest_backup
        latest_backup=$(find "$BACKUP_DIR" -name "tailsentry-backup-*.tar.gz" -type f -printf '%T@ %p\n' 2>/dev/null | sort -n | tail -1 | cut -d' ' -f2-)
        if [[ -n "$latest_backup" ]]; then
            local backup_date
            backup_date=$(stat -c %y "$latest_backup" | cut -d' ' -f1)
            echo -e "Last Backup: ${CYAN}$backup_date${NC}"
        fi
    fi
    
    # Check disk usage
    if [[ -d "$INSTALL_DIR" ]]; then
        local disk_usage
        disk_usage=$(du -sh "$INSTALL_DIR" 2>/dev/null | cut -f1)
        echo -e "Disk Usage: ${CYAN}$disk_usage${NC}"
    fi
}

manage_service() {
    local action="$1"
    
    case "$action" in
        "start")
            systemctl start "$SERVICE_NAME"
            success "Service started"
            ;;
        "stop")
            systemctl stop "$SERVICE_NAME"
            success "Service stopped"
            ;;
        "restart")
            systemctl restart "$SERVICE_NAME"
            success "Service restarted"
            ;;
        "enable")
            systemctl enable "$SERVICE_NAME"
            success "Service enabled"
            ;;
        "disable")
            systemctl disable "$SERVICE_NAME"
            success "Service disabled"
            ;;
        "logs")
            journalctl -u "$SERVICE_NAME" -f
            ;;
        *)
            error "Unknown service action: $action"
            return 1
            ;;
    esac
}

# ============================================================================
# MENU FUNCTIONS
# ============================================================================

show_help() {
    cat << EOF
$APP_NAME Installer/Manager v$SCRIPT_VERSION

USAGE:
    $0 [COMMAND] [OPTIONS]

COMMANDS:
    install         Fresh installation of $APP_NAME
    update          Update $APP_NAME to latest version
    update-deps     Update Python dependencies only
    uninstall       Remove $APP_NAME completely
    status          Show current status
    backup          Create manual backup
    restore         Restore from backup
    list-backups    List available backups
    
    Service Management:
    start           Start the service
    stop            Stop the service
    restart         Restart the service
    enable          Enable service auto-start
    disable         Disable service auto-start
    logs            Show service logs (live)
    
    help            Show this help message

EXAMPLES:
    $0 install          # Fresh installation
    $0 update           # Update application
    $0 status           # Check status
    $0 restart          # Restart service
    $0 logs             # Show live logs

For more information, visit: https://github.com/lolerskatez/TailSentry
EOF
}

interactive_menu() {
    while true; do
        print_header
        show_status 2>/dev/null || true
        print_separator
        
        echo -e "${WHITE}Available Actions:${NC}"
        echo "1. Install $APP_NAME"
        echo "2. Update $APP_NAME"
        echo "3. Update Dependencies Only"
        echo "4. Uninstall $APP_NAME"
        echo "5. Create Backup"
        echo "6. Restore from Backup"
        echo "7. List Backups"
        echo "8. Service Management"
        echo "9. View Logs"
        echo "0. Exit"
        echo ""
        
        read -r -p "Choose an option [0-9]: " choice
        
        case "$choice" in
            1)
                check_root
                check_system
                install_dependencies
                download_application
                setup_python_environment
                configure_application
                install_service
                systemctl start "$SERVICE_NAME"
                success "$APP_NAME installation completed!"
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            2)
                check_root
                update_application
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            3)
                check_root
                update_dependencies
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            4)
                check_root
                uninstall_application
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            5)
                check_root
                create_backup
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            6)
                check_root
                restore_backup
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            7)
                list_backups
                echo ""
                read -r -p "Press Enter to continue..."
                ;;
            8)
                service_menu
                ;;
            9)
                manage_service "logs"
                ;;
            0)
                echo "Goodbye!"
                exit 0
                ;;
            *)
                error "Invalid option"
                sleep 1
                ;;
        esac
    done
}

service_menu() {
    while true; do
        print_separator
        echo -e "${WHITE}Service Management:${NC}"
        echo "1. Start Service"
        echo "2. Stop Service"
        echo "3. Restart Service"
        echo "4. Enable Auto-start"
        echo "5. Disable Auto-start"
        echo "6. View Logs"
        echo "0. Back to Main Menu"
        echo ""
        
        read -r -p "Choose an option [0-6]: " choice
        
        case "$choice" in
            1) manage_service "start"; read -r -p "Press Enter to continue..." ;;
            2) manage_service "stop"; read -r -p "Press Enter to continue..." ;;
            3) manage_service "restart"; read -r -p "Press Enter to continue..." ;;
            4) manage_service "enable"; read -r -p "Press Enter to continue..." ;;
            5) manage_service "disable"; read -r -p "Press Enter to continue..." ;;
            6) manage_service "logs" ;;
            0) break ;;
            *) error "Invalid option"; sleep 1 ;;
        esac
    done
}

# ============================================================================
# MAIN EXECUTION
# ============================================================================

main() {
    # Create log file
    touch "$LOG_FILE"
    
    # Handle command line arguments
    case "${1:-}" in
        "install")
            print_header
            check_root
            check_system
            install_dependencies
            download_application
            setup_python_environment
            configure_application
            install_service
            systemctl start "$SERVICE_NAME"
            success "$APP_NAME installation completed!"
            ;;
        "update")
            check_root
            update_application
            ;;
        "update-deps")
            check_root
            update_dependencies
            ;;
        "uninstall")
            check_root
            uninstall_application
            ;;
        "status")
            show_status
            ;;
        "backup")
            check_root
            create_backup
            ;;
        "restore")
            check_root
            restore_backup
            ;;
        "list-backups")
            list_backups
            ;;
        "start"|"stop"|"restart"|"enable"|"disable"|"logs")
            check_root
            manage_service "$1"
            ;;
        "help"|"--help"|"-h")
            show_help
            ;;
        "")
            # No arguments - run interactive menu
            interactive_menu
            ;;
        *)
            error "Unknown command: $1"
            echo ""
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
